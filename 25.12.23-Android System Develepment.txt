25.12.23	Android系统开发笔试题

1.

2.（针对网络）在弱网环境下（如高延迟、不稳定），为保证控制指令的可靠送达，应用层可以采取哪些策略？系统层面（如网络管理）又可以做哪些优化？

Answer：
一、应用层可以采取的策略
1️⃣ 重试与确认机制（ACK + 重传）

控制指令发送后要求对端返回 ACK 确认

超时未收到 ACK → 自动重传

设置最大重试次数，避免无限重发

👉 核心目标：保证“送达”而不是“只发一次”

2️⃣ 序列号 / 幂等设计

每条指令携带 序列号 / requestId

接收端可：

去重（避免重复执行）

按顺序执行

👉 防止弱网下 乱序 / 重复执行控制指令

3️⃣ 本地缓存与队列

指令先写入本地队列

网络恢复后 批量或顺序发送

失败可回滚或延迟执行

👉 常用于 IoT、远程控制、IM、支付场景

4️⃣ 指令优先级控制

控制类指令 > 普通数据

弱网时：

丢弃非关键数据

优先保证控制指令

5️⃣ 压缩与精简协议

使用二进制协议（如 Protobuf）

压缩数据体，减少包大小

合并多条小指令

👉 降低弱网下的丢包概率

6️⃣ 心跳与连接保活

定期心跳检测链路状态

断线快速重连

判断“假在线 / 真离线”

二、系统层（网络管理层）可以做的优化
1️⃣ 网络质量监测与自适应

实时监测：

RTT（延迟）

丢包率

带宽

根据网络状况：

动态调整发送频率

降级数据质量

2️⃣ QoS / 流量调度

为控制指令设置 高优先级 QoS

避免被大流量数据挤占带宽

👉 系统层“让重要包先走”

3️⃣ TCP 参数与协议优化

调整 TCP：

重传超时（RTO）

拥塞控制策略

某些场景使用：

UDP + 应用层可靠性

QUIC

4️⃣ 多链路 / 多网络切换

Wi-Fi ↔ 蜂窝网络自动切换

双通道冗余发送（关键控制指令）

5️⃣ 网络层缓存与代理

本地代理缓存指令

边缘节点（CDN / 边缘计算）减少 RTT

三、总结式回答（适合直接背）

在弱网环境下，应用层可以通过 ACK + 重试、序列号去重、本地缓存、指令优先级、数据压缩和心跳机制 来保证控制指令的可靠送达；
系统层则可以通过 网络质量监测、自适应策略、QoS 优先级调度、协议参数优化以及多网络切换 等方式，从底层提升链路的稳定性和可靠性。


3.请简述在 Android 系统中，系统应用（System App）与自行开发的应用在合成常见服务通信方案中存在的通信时，你会选择哪种 IPC 机制？并对比分析其优缺点（如 AIDL、Binder、Socket 等）。

Answer：
這是一道關於 Android 多進程通信（IPC）設計的技術題。題目要求在「大數據量」且「低延遲」的場景下（System App 與後台服務通信），選擇最合適的 IPC 機制並進行對比分析。針對此場景，以下是專業的技術回答建議：核心建議：選擇「MemoryFile + Binder」或「Socket」在 Android 中，普通的 Binder (AIDL) 傳輸數據有大小限制（通常為 1MB 的緩衝區限制），對於大數據傳輸並不直接適用。因此，最佳方案通常是結合使用。方案 1：Binder + 匿名共享內存 (Ashmem/MemoryFile) —— 最優選這是 Android 系統底層處理大數據（如圖像、音頻）的標準做法。機制： 使用 MemoryFile 創建共享內存，通過 Binder 將 FileDescriptor (FD) 傳遞給對方。優點： 數據無需在進程間多次拷貝，實現「零拷貝」或極少拷貝，延遲極低。缺點： 實現複雜度較高，需要手動管理內存生命週期與並發訪問。方案 2：LocalSocket機制： 使用 Linux 層面的局部套接字進行流式傳輸。優點： 傳輸數據量不受限制，穩定性強。缺點： 涉及兩次內存拷貝（用戶空間 -> 內核空間 -> 用戶空間），延遲略高於共享內存。IPC 機制對比分析表機制適合場景優點缺點Binder (AIDL)普通傳令、短數據速度快（僅一次拷貝）、CS 架構清晰、安全性高。有大小限制（~1MB），不適合大數據傳輸。共享內存 (Ashmem)大數據、低延遲性能最高，大數據傳輸無需數據拷貝。需配合 Binder 傳遞 FD，無同步機制，需自行處理讀寫鎖。Socket大規模流數據、跨網絡數據量不受限，接口通用，適合解耦。兩次拷貝，開銷比 Binder 大，延遲相對較高。ContentProvider跨應用數據共享支持 SQL 查詢，封裝良好，易於數據管理。底層基於 Binder，對於頻繁的大量原始數據讀寫效率較低。Messenger輕量級異步消息實現簡單，內置 Handler 線程池。串行處理，不支持並發，大數據量下效率極低。綜合總結與設計思路針對題目中的 System App 與 後台服務 通信：首選方案： AIDL + MemoryFile。利用 Binder 傳遞指令和內存文件描述符（低延遲、高安全性）。利用共享內存傳遞大數據實體（突破 1MB 限制，極致性能）。次選方案： LocalSocket。如果數據是以「流」的形式不斷產生（如傳感器原始流或視頻流），Socket 的穩定性和流式處理更具優勢。面試加分項：可以提一下 Android 系統中的 SharedMemory API（Android 8.0+ 引入），它是對 Ashmem 的官方封裝，提供了更好的內存保護機制，非常適合 System App 層級的開發。

4.

5.什么是 ANR？导致 ANR 的根本原因有哪些？如何系统性地定位和轻点一个由系统修改引发的 ANR 问题？

Answer：
這道題目探討的是 Android 開發中非常核心的性能問題：ANR (Application Not Responding)。針對「系統級修改」引發的 ANR，分析維度需要從應用層上升到系統服務與內核層。

以下是系統化的回答架構：

1. 什麼是 ANR？
ANR (Application Not Responding) 指應用程序未響應。當 Android 的**主線程（UI 線程）**在特定時間內無法處理輸入事件或特定生命週期回調時，系統監控機制（Watchdog 或各個服務的超時檢測）就會彈出一個對話框，提示用戶應用無響應。

常見超時閥值：

KeyDispatchTimeout (Input): 5 秒內未響應輸入事件。

BroadcastTimeout: 前台廣播 10 秒，後台廣播 60 秒。

ServiceTimeout: 前台服務 20 秒，後台服務 200 秒。

ContentProviderTimeout: 10 秒內未發布。

2. 導致 ANR 的根本原因
根本原因可以歸納為：主線程被阻塞，無法及時執行任務。 具體誘因包括：

耗時操作： 在主線程進行網絡請求、大文件 IO、複雜數據庫查詢或繁重計算。

鎖競爭 (Deadlock/Lock Wait): 主線程等待一個被其他線程持有的鎖（尤其是被高負載的後台線程持有的鎖）。

系統資源耗盡： CPU 佔用率過高（導致主線程調度不到）、IO 負載過大（IO Wait）、內存洩漏導致頻繁 GC 引發的 Stop-the-world。

Binder 耗時： 調用遠程進程方法（IPC）時，對方響應慢或 Binder 線程池耗盡。

3. 如何定位系統級修改引發的 ANR？
針對「系統級修改」導致的問題，通常不能僅靠代碼走查，需要通過日誌與工具進行「全棧式」定位：

第一步：分析日誌文件 (Logcat & Traces)
檢索 ANR in： 在 Logcat 中找到觸發 ANR 的時間點和進程。

提取 /data/anr/traces.txt： 這是最重要的文件。它記錄了 ANR 發生時所有線程的調用棧（Call Stack）。

觀察主線程狀態： 狀態是 WAITING (等鎖)、BLOCKED 還是 NATIVE (執行系統底層邏輯)？

分析關鍵字： 搜索系統關鍵路徑，看是否有新修改的底層 API 出現在調用棧中。

第二步：使用性能分析工具
Systrace / Perfetto (推薦)： 這是定位系統級問題的神器。

它可以看清 CPU 調度情況：主線程是否在運行（Running）？還是在等待（Runnable）？

可以看到 Binder 調用軌跡：是否某個系統服務（如 WindowManagerService）處理過慢，導致你的應用被掛起。

Top / Procrank： 查看當前系統整體的 CPU 和內存負載。如果是因為某個系統守護進程死循環導致系統變慢，這裡能一眼看出。

4. 系統級 ANR 的解決方案
定位到問題後，根據誘因對症下藥：

優化系統調度： 如果修改導致了 CPU 爭搶，調整重要線程的 Cgroups 或 Thread Priority。

異步處理： 將系統級的長耗時操作從關鍵服務路徑中解耦，移至工作線程或使用消息隊列。

鎖粒度優化： 在系統框架修改中，避免使用大範圍的全局鎖（如 synchronized(mLock) 跨多個組件），防止 Binder 調用引發的連鎖性鎖等待。

Binder 隔離： 如果是跨進程通信導致的超時，考慮增加超時檢測機制，或者將同步調用改為異步回調。

總結回答思路： 先定義（現象），再分類（原因），重分析（日誌+工具），最後給方案。